# -*- coding: utf-8 -*-
"""A*Rep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15uJ5aUKK_nk9Mdgn7HdZYReyB1XPHKKf

# New section
"""

import heapq


graph = {
    "Tokyo": {"Paris": 270, "South Africa": 180},
    "Paris": {"Tokyo": 270, "New york": 190},
    "South Africa": {"Tokyo": 180, "Uganda": 220},
    "Uganda": {"South Africa": 220, "Moscow": 880},
    "New york": {"Paris": 190},
    "Moscow": {"Uganda": 880}
}


heuristic = {
    "Tokyo": 1210,
    "Paris": 1100,
    "South Africa": 1050,
    "Uganda": 880,
    "New york": 1250,
    "Moscow": 0
}

def a_star(graph, start, goal, heuristic):
    """
    A* search returns (path, total_cost) or (None, inf) if no path found.
    We store paths in the priority heapq together with their f-cost = g + h.
    """
    open_list = []

    heapq.heappush(open_list, (heuristic[start], [start]))
    g_costs = {start: 0}
    closed_set = set()


    while open_list:
        f, path = heapq.heappop(open_list)
        node = path[-1]


        if node == goal:
            return path, g_costs[node]


        if node in closed_set:
            continue

        closed_set.add(node)

        for neighbor, cost in graph[node].items():
            tentative_g = g_costs[node] + cost


            if neighbor not in g_costs or tentative_g < g_costs[neighbor]:
                g_costs[neighbor] = tentative_g
                f_cost = tentative_g + heuristic.get(neighbor, float('inf'))
                new_path = path + [neighbor]
                heapq.heappush(open_list, (f_cost, new_path))


    return None, float('inf')


if __name__ == "__main__":
    start_city = "Tokyo"
    goal_city = "Moscow"
    path, cost = a_star(graph, start_city, goal_city, heuristic)
    print("A* path:", path)
    print("Total cost:", cost)

"""# **Water Jug Q/A**

**Q1:** Compare the solution paths found by BFS, DFS, and A*.
**Answer:**
BFS Solution
(0, 0)
(4, 0)
(1, 3)

DFS Solution
(0, 0)
(0, 3)
(3, 0)
(3, 3)
(4, 2)
(4, 0)
(1, 3)

A* solution
(0, 0)
(4, 0)
(1, 3)



**Q2:** Which algorithm gives the shortest path? Why?
**Answer:**BFS and A* give the shortest path.

BFS explores level by level, so the first time it finds the goal, it guarantees the minimum number of steps.

A* also finds the shortest path here because the heuristic is admissible (it never overestimates the distance to the goal).

 DFS does not guarantee the shortest path, it just finds a path. Thats why it gave a longer sequence.

 **Q3:**Which algorithm is more efficient in terms of time and memory?
** Answer:**
Efficiency depends on time and memory:

**BFS**

Time: May expand many nodes because it explores all states level by level.

Memory: Uses a queue that can hold many nodes (can blow up in large state spaces).

Strength: Guarantees shortest path.

**DFS**

Time: Can sometimes find a solution quickly, but not guaranteed.

Memory: Uses a stack, which is more memory efficient than BFS because it doesn’t store entire levels at once.

Weakness: May explore deep unnecessary paths, doesn’t guarantee shortest path.

**A(*)**

Time: Usually explores fewer nodes than BFS if the heuristic is good.

Memory: Needs to keep track of open and closed sets (priority queue + visited costs), so can use more memory than DFS.

Strength: Combines BFS’s optimality with better efficiency (if heuristic is admissible and informative).
"""