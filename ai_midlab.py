# -*- coding: utf-8 -*-
"""AI_Midlab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10cygT1VhIkqa7eh5nfSQN7iXfn-QsjIJ

# SYED HAMMAD RAZA (SP23-BSE-089)

**Question 1 Answer**
"""

# ============================================
# AI Lab Task - Missionaries and Cannibals Problem
# Implemented using BFS, DFS, and A* Search
# Author: Syed Hammad Raza
# Roll No: SP23-BSE-089
# ============================================

from collections import deque
import heapq

# State Representation: (M_left, C_left, Boat_position)
# Boat_position = 'left' or 'right'
# Goal: (0, 0, 'right')

TOTAL_M = 3
TOTAL_C = 3

# --------------------------
# Helper Functions
# --------------------------

def is_valid_state(M_left, C_left):
    """Check if the state is valid."""
    M_right = TOTAL_M - M_left
    C_right = TOTAL_C - C_left

    if M_left < 0 or C_left < 0 or M_right < 0 or C_right < 0:
        return False
    if (M_left > 0 and C_left > M_left):
        return False
    if (M_right > 0 and C_right > M_right):
        return False
    return True


def get_successors(state):
    """Generate all valid next states."""
    M_left, C_left, boat = state
    successors = []
    moves = [(1,0), (2,0), (0,1), (0,2), (1,1)]  # Possible moves

    for m, c in moves:
        if boat == 'left':
            new_state = (M_left - m, C_left - c, 'right')
        else:
            new_state = (M_left + m, C_left + c, 'left')

        if is_valid_state(new_state[0], new_state[1]):
            successors.append(new_state)
    return successors


def print_path(path):
    """Nicely display the path."""
    print("\n--- Solution Path ---")
    for step, state in enumerate(path):
        print(f"Step {step}: {state}")
    print("---------------------\n")


# --------------------------
# 1. Breadth-First Search (BFS)
# --------------------------

def bfs(start):
    queue = deque([(start, [start])])
    visited = set()

    while queue:
        (state, path) = queue.popleft()
        if state in visited:
            continue
        visited.add(state)

        if state == (0, 0, 'right'):
            print("BFS Solution Found ✅")
            print_path(path)
            return path

        for next_state in get_successors(state):
            if next_state not in visited:
                queue.append((next_state, path + [next_state]))
    print("No solution found using BFS ❌")
    return None


# --------------------------
# 2. Depth-First Search (DFS)
# --------------------------

def dfs(start):
    stack = [(start, [start])]
    visited = set()

    while stack:
        (state, path) = stack.pop()
        if state in visited:
            continue
        visited.add(state)

        if state == (0, 0, 'right'):
            print("DFS Solution Found ✅")
            print_path(path)
            return path

        for next_state in get_successors(state):
            if next_state not in visited:
                stack.append((next_state, path + [next_state]))
    print("No solution found using DFS ❌")
    return None


# --------------------------
# 3. A* Search Algorithm
# --------------------------

def heuristic(state):
    """Estimate how far we are from goal."""
    M_left, C_left, _ = state
    return M_left + C_left  # Remaining people to move


def astar(start):
    pq = []
    heapq.heappush(pq, (heuristic(start), 0, start, [start]))
    visited = set()

    while pq:
        (h, cost, state, path) = heapq.heappop(pq)
        if state in visited:
            continue
        visited.add(state)

        if state == (0, 0, 'right'):
            print("A* Solution Found ✅")
            print_path(path)
            return path

        for next_state in get_successors(state):
            if next_state not in visited:
                new_cost = cost + 1
                priority = new_cost + heuristic(next_state)
                heapq.heappush(pq, (priority, new_cost, next_state, path + [next_state]))
    print("No solution found using A* ❌")
    return None


# --------------------------
# Main Execution
# --------------------------

if __name__ == "__main__":
    start_state = (3, 3, 'left')
    print("Starting State:", start_state)
    print("Goal State: (0, 0, 'right')\n")

    bfs(start_state)
    dfs(start_state)
    astar(start_state)