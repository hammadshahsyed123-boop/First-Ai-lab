# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jje02j7XadUvKtSPBnVtM8avchwPC_xf

# Student Info Dictionary
"""

student = {
    "name": "Ali",
    "age": 21,
    "roll_number": "BSC-123",
    "grade": "B"
}

# 1. Print keys and values
print("Keys:", student.keys())
print("Values:", student.values())


student["grade"] = "A"
print("Updated grade:", student["grade"])


student["email"] = "ali@example.com"
print("After adding email:", student)

del student["roll_number"]
print("After deleting roll_number:", student)

"""# Line Plot Matplotlib"""

import matplotlib.pyplot as plt

# Data
X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

# Create plot
plt.plot(X, Y, marker='o')
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.grid(True)
plt.show()

"""# Water Jug Problem using BFS & DFS"""

from collections import deque
import time
import sys

JUG1 = 4  # Capacity of Jug 1
JUG2 = 3  # Capacity of Jug 2
GOAL = 1

# BFS
def water_jug_bfs():
    start = (0, 0)
    visited = set()
    queue = deque([[start]])

    while queue:
        path = queue.popleft()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state
        next_states = set()

        # Fill Jug1 or Jug2
        next_states.add((JUG1, y))
        next_states.add((x, JUG2))
        # Empty Jug1 or Jug2
        next_states.add((0, y))
        next_states.add((x, 0))
        # Pour Jug1 -> Jug2
        pour = min(x, JUG2 - y)
        next_states.add((x - pour, y + pour))
        # Pour Jug2 -> Jug1
        pour = min(y, JUG1 - x)
        next_states.add((x + pour, y - pour))

        for s in next_states:
            if s not in visited:
                queue.append(path + [s])

# DFS
def water_jug_dfs():
    start = (0, 0)
    stack = [[start]]
    visited = set()

    while stack:
        path = stack.pop()
        state = path[-1]

        if state[0] == GOAL or state[1] == GOAL:
            return path

        if state in visited:
            continue
        visited.add(state)

        x, y = state
        next_states = set()

        next_states.add((JUG1, y))
        next_states.add((x, JUG2))
        next_states.add((0, y))
        next_states.add((x, 0))
        pour = min(x, JUG2 - y)
        next_states.add((x - pour, y + pour))
        pour = min(y, JUG1 - x)
        next_states.add((x + pour, y - pour))

        for s in next_states:
            if s not in visited:
                stack.append(path + [s])

# Compare performance
start_time = time.time()
bfs_path = water_jug_bfs()
bfs_time = time.time() - start_time
bfs_memory = sys.getsizeof(bfs_path)

start_time = time.time()
dfs_path = water_jug_dfs()
dfs_time = time.time() - start_time
dfs_memory = sys.getsizeof(dfs_path)

print("BFS Path:", bfs_path)
print("BFS Steps:", len(bfs_path), "Time:", bfs_time, "Memory:", bfs_memory)

print("DFS Path:", dfs_path)
print("DFS Steps:", len(dfs_path), "Time:", dfs_time, "Memory:", dfs_memory)

"""# A Search in a Maze"""

import heapq

# Example Maze (0 = free, 1 = wall)
maze = [
    [0, 0, 0, 1],
    [1, 0, 0, 1],
    [0, 0, 0, 0],
    [0, 1, 0, 0]
]

start = (0, 0)  # A
goal = (3, 3)   # Y

def heuristic(a, b):
    return abs(a[0]-b[0]) + abs(a[1]-b[1])  # Manhattan distance

def astar(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = []
    heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start, [start]))
    visited = set()

    while open_set:
        f, g, current, path = heapq.heappop(open_set)
        if current == goal:
            return path

        if current in visited:
            continue
        visited.add(current)

        x, y = current
        for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)]:
            nx, ny = x+dx, y+dy
            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0:
                heapq.heappush(open_set, (g+1+heuristic((nx, ny), goal), g+1, (nx, ny), path+[(nx, ny)]))

path = astar(maze, start, goal)
print("A* Path:", path)
print("Steps:", len(path))